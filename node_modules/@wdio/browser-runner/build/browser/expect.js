// src/browser/expect.ts
import { expect } from "expect";
import { MESSAGE_TYPES } from "@wdio/types";
import { $ } from "@wdio/globals";

// src/browser/utils.ts
function getCID() {
  var _a3;
  const urlParamString = new URLSearchParams(window.location.search);
  const cid = (
    // initial request contains cid as query parameter
    urlParamString.get("cid") || // if not provided check for document cookie, set by `@wdio/runner` package
    ((_a3 = (document.cookie.split(";") || []).find((c) => c.includes("WDIO_CID"))) == null ? void 0 : _a3.trim().split("=").pop())
  );
  if (!cid) {
    throw new Error('"cid" query parameter is missing');
  }
  return cid;
}

// src/constants.ts
var WDIO_EVENT_NAME = "wdio:workerMessage";

// src/browser/expect.ts
var asymmetricMatcher = typeof Symbol === "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var matcherRequestCount = 0;
var matcherRequests = /* @__PURE__ */ new Map();
var COMMAND_TIMEOUT = 30 * 1e3;
function createMatcher(matcherName) {
  return async function(context, ...args) {
    var _a3, _b;
    const cid = getCID();
    if (!import.meta.hot || !cid) {
      return {
        pass: false,
        message: () => "Could not connect to testrunner"
      };
    }
    if (typeof args[0] === "object" && "$$typeof" in args[0] && args[0].$$typeof === asymmetricMatcher && args[0].asymmetricMatch) {
      args[0] = {
        $$typeof: args[0].toString(),
        sample: args[0].sample,
        inverse: args[0].inverse
      };
    }
    const expectRequest = {
      id: matcherRequestCount++,
      cid,
      scope: this,
      matcherName,
      args
    };
    const isContextObject = typeof context === "object";
    if (isContextObject && "selector" in context && "selector" in context) {
      expectRequest.element = context;
    }
    if (isContextObject && "then" in context && typeof context.selector === "object") {
      expectRequest.element = await context;
    }
    if (context instanceof Element) {
      expectRequest.element = await $(context);
    } else if (isContextObject && !("sessionId" in context)) {
      expectRequest.context = context;
      if ("then" in context) {
        expectRequest.context = await context;
      }
    } else if (!isContextObject) {
      expectRequest.context = context;
    }
    if (expectRequest.element && typeof expectRequest.element.selector !== "string") {
      expectRequest.element.selector = void 0;
    }
    if (matcherName === "toMatchInlineSnapshot") {
      expectRequest.scope.errorStack = (_b = (_a3 = new Error("inline snapshot error").stack) == null ? void 0 : _a3.split("\n").find((line) => line.includes(window.__wdioSpec__))) == null ? void 0 : _b.replace(/http:\/\/localhost:\d+/g, "").replace("/@fs/", "/");
    }
    import.meta.hot.send(WDIO_EVENT_NAME, { type: MESSAGE_TYPES.expectRequestMessage, value: expectRequest });
    const contextString = isContextObject ? "elementId" in context ? "WebdriverIO.Element" : "WebdriverIO.Browser" : context;
    return new Promise((resolve, reject) => {
      const commandTimeout = setTimeout(
        () => reject(new Error("Assertion expect(".concat(contextString, ").").concat(matcherName, "(...) timed out"))),
        COMMAND_TIMEOUT
      );
      matcherRequests.set(expectRequest.id, { resolve, commandTimeout });
    });
  };
}
var _a;
(_a = import.meta.hot) == null ? void 0 : _a.send(WDIO_EVENT_NAME, { type: MESSAGE_TYPES.expectMatchersRequest });
var _a2;
(_a2 = import.meta.hot) == null ? void 0 : _a2.on(WDIO_EVENT_NAME, (message) => {
  if (message.type === MESSAGE_TYPES.expectMatchersResponse) {
    const matchers = message.value.matchers.reduce((acc, matcherName) => {
      acc[matcherName] = createMatcher(matcherName);
      return acc;
    }, {});
    expect.extend(matchers);
  }
  if (message.type !== MESSAGE_TYPES.expectResponseMessage) {
    return;
  }
  const payload = matcherRequests.get(message.value.id);
  if (!payload) {
    return console.warn("Couldn't find payload for assertion result with id ".concat(message.value.id));
  }
  clearTimeout(payload.commandTimeout);
  matcherRequests.delete(message.value.id);
  payload.resolve({
    pass: message.value.pass,
    message: () => message.value.message
  });
});
export {
  expect
};
