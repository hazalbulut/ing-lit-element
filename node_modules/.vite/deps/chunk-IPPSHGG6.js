import {
  require_source
} from "./chunk-AI5UDCR7.js";
import {
  __commonJS
} from "./chunk-VUNV25KB.js";

// node_modules/jest-get-type/build/index.js
var require_build = __commonJS({
  "node_modules/jest-get-type/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getType = getType;
    exports.isPrimitive = void 0;
    function getType(value) {
      if (value === void 0) {
        return "undefined";
      } else if (value === null) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      } else if (typeof value === "boolean") {
        return "boolean";
      } else if (typeof value === "function") {
        return "function";
      } else if (typeof value === "number") {
        return "number";
      } else if (typeof value === "string") {
        return "string";
      } else if (typeof value === "bigint") {
        return "bigint";
      } else if (typeof value === "object") {
        if (value != null) {
          if (value.constructor === RegExp) {
            return "regexp";
          } else if (value.constructor === Map) {
            return "map";
          } else if (value.constructor === Set) {
            return "set";
          } else if (value.constructor === Date) {
            return "date";
          }
        }
        return "object";
      } else if (typeof value === "symbol") {
        return "symbol";
      }
      throw new Error(`value of unknown type: ${value}`);
    }
    var isPrimitive = (value) => Object(value) !== value;
    exports.isPrimitive = isPrimitive;
  }
});

// node_modules/pretty-format/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/pretty-format/node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi256 = wrapAnsi256();
      styles.color.ansi16m = wrapAnsi16m();
      styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/pretty-format/build/collections.js
var require_collections = __commonJS({
  "node_modules/pretty-format/build/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printIteratorEntries = printIteratorEntries;
    exports.printIteratorValues = printIteratorValues;
    exports.printListItems = printListItems;
    exports.printObjectProperties = printObjectProperties;
    var getKeysOfEnumerableProperties = (object, compareKeys) => {
      const rawKeys = Object.keys(object);
      const keys = compareKeys !== null ? rawKeys.sort(compareKeys) : rawKeys;
      if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(object).forEach((symbol) => {
          if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
            keys.push(symbol);
          }
        });
      }
      return keys;
    };
    function printIteratorEntries(iterator, config, indentation, depth, refs, printer, separator = ": ") {
      let result = "";
      let width = 0;
      let current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while (!current.done) {
          result += indentationNext;
          if (width++ === config.maxWidth) {
            result += "…";
            break;
          }
          const name = printer(
            current.value[0],
            config,
            indentationNext,
            depth,
            refs
          );
          const value = printer(
            current.value[1],
            config,
            indentationNext,
            depth,
            refs
          );
          result += name + separator + value;
          current = iterator.next();
          if (!current.done) {
            result += `,${config.spacingInner}`;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
      let result = "";
      let width = 0;
      let current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while (!current.done) {
          result += indentationNext;
          if (width++ === config.maxWidth) {
            result += "…";
            break;
          }
          result += printer(current.value, config, indentationNext, depth, refs);
          current = iterator.next();
          if (!current.done) {
            result += `,${config.spacingInner}`;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printListItems(list, config, indentation, depth, refs, printer) {
      let result = "";
      if (list.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for (let i = 0; i < list.length; i++) {
          result += indentationNext;
          if (i === config.maxWidth) {
            result += "…";
            break;
          }
          if (i in list) {
            result += printer(list[i], config, indentationNext, depth, refs);
          }
          if (i < list.length - 1) {
            result += `,${config.spacingInner}`;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printObjectProperties(val, config, indentation, depth, refs, printer) {
      let result = "";
      const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
      if (keys.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const name = printer(key, config, indentationNext, depth, refs);
          const value = printer(val[key], config, indentationNext, depth, refs);
          result += `${indentationNext + name}: ${value}`;
          if (i < keys.length - 1) {
            result += `,${config.spacingInner}`;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
  }
});

// node_modules/pretty-format/build/plugins/AsymmetricMatcher.js
var require_AsymmetricMatcher = __commonJS({
  "node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections();
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var asymmetricMatcher = typeof Symbol2 === "function" && Symbol2.for ? Symbol2.for("jest.asymmetricMatcher") : 1267621;
    var SPACE = " ";
    var serialize = (val, config, indentation, depth, refs, printer) => {
      const stringedValue = val.toString();
      if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
        if (++depth > config.maxDepth) {
          return `[${stringedValue}]`;
        }
        return `${stringedValue + SPACE}[${(0, _collections.printListItems)(
          val.sample,
          config,
          indentation,
          depth,
          refs,
          printer
        )}]`;
      }
      if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
        if (++depth > config.maxDepth) {
          return `[${stringedValue}]`;
        }
        return `${stringedValue + SPACE}{${(0, _collections.printObjectProperties)(
          val.sample,
          config,
          indentation,
          depth,
          refs,
          printer
        )}}`;
      }
      if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }
      if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }
      if (typeof val.toAsymmetricMatcher !== "function") {
        throw new Error(
          `Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`
        );
      }
      return val.toAsymmetricMatcher();
    };
    exports.serialize = serialize;
    var test = (val) => val && val.$$typeof === asymmetricMatcher;
    exports.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/DOMCollection.js
var require_DOMCollection = __commonJS({
  "node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections();
    var SPACE = " ";
    var OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
    var ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
    var testName = (name) => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
    var test = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
    exports.test = test;
    var isNamedNodeMap = (collection) => collection.constructor.name === "NamedNodeMap";
    var serialize = (collection, config, indentation, depth, refs, printer) => {
      const name = collection.constructor.name;
      if (++depth > config.maxDepth) {
        return `[${name}]`;
      }
      return (config.min ? "" : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? `{${(0, _collections.printObjectProperties)(
        isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
          props[attribute.name] = attribute.value;
          return props;
        }, {}) : {
          ...collection
        },
        config,
        indentation,
        depth,
        refs,
        printer
      )}}` : `[${(0, _collections.printListItems)(
        Array.from(collection),
        config,
        indentation,
        depth,
        refs,
        printer
      )}]`);
    };
    exports.serialize = serialize;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/lib/escapeHTML.js
var require_escapeHTML = __commonJS({
  "node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = escapeHTML;
    function escapeHTML(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
});

// node_modules/pretty-format/build/plugins/lib/markup.js
var require_markup = __commonJS({
  "node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
    var _escapeHTML = _interopRequireDefault(require_escapeHTML());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var printProps = (keys, props, config, indentation, depth, refs, printer) => {
      const indentationNext = indentation + config.indent;
      const colors = config.colors;
      return keys.map((key) => {
        const value = props[key];
        let printed = printer(value, config, indentationNext, depth, refs);
        if (typeof value !== "string") {
          if (printed.indexOf("\n") !== -1) {
            printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
          }
          printed = `{${printed}}`;
        }
        return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
      }).join("");
    };
    exports.printProps = printProps;
    var printChildren = (children, config, indentation, depth, refs, printer) => children.map(
      (child) => config.spacingOuter + indentation + (typeof child === "string" ? printText(child, config) : printer(child, config, indentation, depth, refs))
    ).join("");
    exports.printChildren = printChildren;
    var printText = (text, config) => {
      const contentColor = config.colors.content;
      return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
    };
    exports.printText = printText;
    var printComment = (comment, config) => {
      const commentColor = config.colors.comment;
      return `${commentColor.open}<!--${(0, _escapeHTML.default)(comment)}-->${commentColor.close}`;
    };
    exports.printComment = printComment;
    var printElement = (type, printedProps, printedChildren, config, indentation) => {
      const tagColor = config.colors.tag;
      return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? "" : " "}/`}>${tagColor.close}`;
    };
    exports.printElement = printElement;
    var printElementAsLeaf = (type, config) => {
      const tagColor = config.colors.tag;
      return `${tagColor.open}<${type}${tagColor.close} …${tagColor.open} />${tagColor.close}`;
    };
    exports.printElementAsLeaf = printElementAsLeaf;
  }
});

// node_modules/pretty-format/build/plugins/DOMElement.js
var require_DOMElement = __commonJS({
  "node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup();
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var FRAGMENT_NODE = 11;
    var ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
    var testHasAttribute = (val) => {
      try {
        return typeof val.hasAttribute === "function" && val.hasAttribute("is");
      } catch {
        return false;
      }
    };
    var testNode = (val) => {
      const constructorName = val.constructor.name;
      const { nodeType, tagName } = val;
      const isCustomElement = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
      return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
    };
    var test = (val) => val?.constructor?.name && testNode(val);
    exports.test = test;
    function nodeIsText(node) {
      return node.nodeType === TEXT_NODE;
    }
    function nodeIsComment(node) {
      return node.nodeType === COMMENT_NODE;
    }
    function nodeIsFragment(node) {
      return node.nodeType === FRAGMENT_NODE;
    }
    var serialize = (node, config, indentation, depth, refs, printer) => {
      if (nodeIsText(node)) {
        return (0, _markup.printText)(node.data, config);
      }
      if (nodeIsComment(node)) {
        return (0, _markup.printComment)(node.data, config);
      }
      const type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      if (++depth > config.maxDepth) {
        return (0, _markup.printElementAsLeaf)(type, config);
      }
      return (0, _markup.printElement)(
        type,
        (0, _markup.printProps)(
          nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(),
          nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        (0, _markup.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        config,
        indentation
      );
    };
    exports.serialize = serialize;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/Immutable.js
var require_Immutable = __commonJS({
  "node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections();
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var getImmutableName = (name) => `Immutable.${name}`;
    var printAsLeaf = (name) => `[${name}]`;
    var SPACE = " ";
    var LAZY = "…";
    var printImmutableEntries = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${(0, _collections.printIteratorEntries)(
      val.entries(),
      config,
      indentation,
      depth,
      refs,
      printer
    )}}`;
    function getRecordEntries(val) {
      let i = 0;
      return {
        next() {
          if (i < val._keys.length) {
            const key = val._keys[i++];
            return {
              done: false,
              value: [key, val.get(key)]
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
    var printImmutableRecord = (val, config, indentation, depth, refs, printer) => {
      const name = getImmutableName(val._name || "Record");
      return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${(0, _collections.printIteratorEntries)(
        getRecordEntries(val),
        config,
        indentation,
        depth,
        refs,
        printer
      )}}`;
    };
    var printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
      const name = getImmutableName("Seq");
      if (++depth > config.maxDepth) {
        return printAsLeaf(name);
      }
      if (val[IS_KEYED_SENTINEL]) {
        return `${name + SPACE}{${// from Immutable collection of entries or from ECMAScript object
        val._iter || val._object ? (0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer
        ) : LAZY}}`;
      }
      return `${name + SPACE}[${val._iter || // from Immutable collection of values
      val._array || // from ECMAScript array
      val._collection || // from ECMAScript collection in immutable v4
      val._iterable ? (0, _collections.printIteratorValues)(
        val.values(),
        config,
        indentation,
        depth,
        refs,
        printer
      ) : LAZY}]`;
    };
    var printImmutableValues = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${(0, _collections.printIteratorValues)(
      val.values(),
      config,
      indentation,
      depth,
      refs,
      printer
    )}]`;
    var serialize = (val, config, indentation, depth, refs, printer) => {
      if (val[IS_MAP_SENTINEL]) {
        return printImmutableEntries(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
        );
      }
      if (val[IS_LIST_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "List"
        );
      }
      if (val[IS_SET_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
        );
      }
      if (val[IS_STACK_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "Stack"
        );
      }
      if (val[IS_SEQ_SENTINEL]) {
        return printImmutableSeq(val, config, indentation, depth, refs, printer);
      }
      return printImmutableRecord(val, config, indentation, depth, refs, printer);
    };
    exports.serialize = serialize;
    var test = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
    exports.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/pretty-format/build/plugins/ReactElement.js
var require_ReactElement = __commonJS({
  "node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var ReactIs = _interopRequireWildcard(require_react_is());
    var _markup = require_markup();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var getChildren = (arg, children = []) => {
      if (Array.isArray(arg)) {
        arg.forEach((item) => {
          getChildren(item, children);
        });
      } else if (arg != null && arg !== false) {
        children.push(arg);
      }
      return children;
    };
    var getType = (element) => {
      const type = element.type;
      if (typeof type === "string") {
        return type;
      }
      if (typeof type === "function") {
        return type.displayName || type.name || "Unknown";
      }
      if (ReactIs.isFragment(element)) {
        return "React.Fragment";
      }
      if (ReactIs.isSuspense(element)) {
        return "React.Suspense";
      }
      if (typeof type === "object" && type !== null) {
        if (ReactIs.isContextProvider(element)) {
          return "Context.Provider";
        }
        if (ReactIs.isContextConsumer(element)) {
          return "Context.Consumer";
        }
        if (ReactIs.isForwardRef(element)) {
          if (type.displayName) {
            return type.displayName;
          }
          const functionName = type.render.displayName || type.render.name || "";
          return functionName !== "" ? `ForwardRef(${functionName})` : "ForwardRef";
        }
        if (ReactIs.isMemo(element)) {
          const functionName = type.displayName || type.type.displayName || type.type.name || "";
          return functionName !== "" ? `Memo(${functionName})` : "Memo";
        }
      }
      return "UNDEFINED";
    };
    var getPropKeys = (element) => {
      const { props } = element;
      return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
    };
    var serialize = (element, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(
      getType(element),
      (0, _markup.printProps)(
        getPropKeys(element),
        element.props,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ),
      (0, _markup.printChildren)(
        getChildren(element.props.children),
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ),
      config,
      indentation
    );
    exports.serialize = serialize;
    var test = (val) => val != null && ReactIs.isElement(val);
    exports.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/ReactTestComponent.js
var require_ReactTestComponent = __commonJS({
  "node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup();
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var testSymbol = typeof Symbol2 === "function" && Symbol2.for ? Symbol2.for("react.test.json") : 245830487;
    var getPropKeys = (object) => {
      const { props } = object;
      return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
    };
    var serialize = (object, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(
      object.type,
      object.props ? (0, _markup.printProps)(
        getPropKeys(object),
        object.props,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ) : "",
      object.children ? (0, _markup.printChildren)(
        object.children,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ) : "",
      config,
      indentation
    );
    exports.serialize = serialize;
    var test = (val) => val && val.$$typeof === testSymbol;
    exports.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports.default = _default;
  }
});

// node_modules/pretty-format/build/index.js
var require_build2 = __commonJS({
  "node_modules/pretty-format/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.DEFAULT_OPTIONS = void 0;
    exports.format = format;
    exports.plugins = void 0;
    var _ansiStyles = _interopRequireDefault(require_ansi_styles());
    var _collections = require_collections();
    var _AsymmetricMatcher = _interopRequireDefault(
      require_AsymmetricMatcher()
    );
    var _DOMCollection = _interopRequireDefault(require_DOMCollection());
    var _DOMElement = _interopRequireDefault(require_DOMElement());
    var _Immutable = _interopRequireDefault(require_Immutable());
    var _ReactElement = _interopRequireDefault(require_ReactElement());
    var _ReactTestComponent = _interopRequireDefault(
      require_ReactTestComponent()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toString = Object.prototype.toString;
    var toISOString = Date.prototype.toISOString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var getConstructorName = (val) => typeof val.constructor === "function" && val.constructor.name || "Object";
    var isWindow = (val) => typeof window !== "undefined" && val === window;
    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    var NEWLINE_REGEXP = /\n/gi;
    var PrettyFormatPluginError = class extends Error {
      constructor(message, stack) {
        super(message);
        this.stack = stack;
        this.name = this.constructor.name;
      }
    };
    function isToStringedArrayType(toStringed) {
      return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
    }
    function printNumber(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    function printBigInt(val) {
      return String(`${val}n`);
    }
    function printFunction(val, printFunctionName) {
      if (!printFunctionName) {
        return "[Function]";
      }
      return `[Function ${val.name || "anonymous"}]`;
    }
    function printSymbol(val) {
      return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    }
    function printError(val) {
      return `[${errorToString.call(val)}]`;
    }
    function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
      if (val === true || val === false) {
        return `${val}`;
      }
      if (val === void 0) {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      const typeOf = typeof val;
      if (typeOf === "number") {
        return printNumber(val);
      }
      if (typeOf === "bigint") {
        return printBigInt(val);
      }
      if (typeOf === "string") {
        if (escapeString) {
          return `"${val.replace(/"|\\/g, "\\$&")}"`;
        }
        return `"${val}"`;
      }
      if (typeOf === "function") {
        return printFunction(val, printFunctionName);
      }
      if (typeOf === "symbol") {
        return printSymbol(val);
      }
      const toStringed = toString.call(val);
      if (toStringed === "[object WeakMap]") {
        return "WeakMap {}";
      }
      if (toStringed === "[object WeakSet]") {
        return "WeakSet {}";
      }
      if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
        return printFunction(val, printFunctionName);
      }
      if (toStringed === "[object Symbol]") {
        return printSymbol(val);
      }
      if (toStringed === "[object Date]") {
        return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
      }
      if (toStringed === "[object Error]") {
        return printError(val);
      }
      if (toStringed === "[object RegExp]") {
        if (escapeRegex) {
          return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        return regExpToString.call(val);
      }
      if (val instanceof Error) {
        return printError(val);
      }
      return null;
    }
    function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1) {
        return "[Circular]";
      }
      refs = refs.slice();
      refs.push(val);
      const hitMaxDepth = ++depth > config.maxDepth;
      const min = config.min;
      if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
        return printer(val.toJSON(), config, indentation, depth, refs, true);
      }
      const toStringed = toString.call(val);
      if (toStringed === "[object Arguments]") {
        return hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${(0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        )}]`;
      }
      if (isToStringedArrayType(toStringed)) {
        return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? "" : !config.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${(0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        )}]`;
      }
      if (toStringed === "[object Map]") {
        return hitMaxDepth ? "[Map]" : `Map {${(0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer,
          " => "
        )}}`;
      }
      if (toStringed === "[object Set]") {
        return hitMaxDepth ? "[Set]" : `Set {${(0, _collections.printIteratorValues)(
          val.values(),
          config,
          indentation,
          depth,
          refs,
          printer
        )}}`;
      }
      return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? "" : !config.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${(0, _collections.printObjectProperties)(
        val,
        config,
        indentation,
        depth,
        refs,
        printer
      )}}`;
    }
    function isNewPlugin(plugin) {
      return plugin.serialize != null;
    }
    function printPlugin(plugin, val, config, indentation, depth, refs) {
      let printed;
      try {
        printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(
          val,
          (valChild) => printer(valChild, config, indentation, depth, refs),
          (str) => {
            const indentationNext = indentation + config.indent;
            return indentationNext + str.replace(NEWLINE_REGEXP, `
${indentationNext}`);
          },
          {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner
          },
          config.colors
        );
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
      if (typeof printed !== "string") {
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
        );
      }
      return printed;
    }
    function findPlugin(plugins2, val) {
      for (let p = 0; p < plugins2.length; p++) {
        try {
          if (plugins2[p].test(val)) {
            return plugins2[p];
          }
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
      }
      return null;
    }
    function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
      const plugin = findPlugin(config.plugins, val);
      if (plugin !== null) {
        return printPlugin(plugin, val, config, indentation, depth, refs);
      }
      const basicResult = printBasicValue(
        val,
        config.printFunctionName,
        config.escapeRegex,
        config.escapeString
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(
        val,
        config,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    var DEFAULT_THEME = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    };
    var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
    var toOptionsSubtype = (options) => options;
    var DEFAULT_OPTIONS = toOptionsSubtype({
      callToJSON: true,
      compareKeys: void 0,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: Infinity,
      maxWidth: Infinity,
      min: false,
      plugins: [],
      printBasicPrototype: true,
      printFunctionName: true,
      theme: DEFAULT_THEME
    });
    exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
    function validateOptions(options) {
      Object.keys(options).forEach((key) => {
        if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {
          throw new Error(`pretty-format: Unknown option "${key}".`);
        }
      });
      if (options.min && options.indent !== void 0 && options.indent !== 0) {
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      }
      if (options.theme !== void 0) {
        if (options.theme === null) {
          throw new Error('pretty-format: Option "theme" must not be null.');
        }
        if (typeof options.theme !== "object") {
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
          );
        }
      }
    }
    var getColorsHighlight = (options) => DEFAULT_THEME_KEYS.reduce((colors, key) => {
      const value = options.theme && options.theme[key] !== void 0 ? options.theme[key] : DEFAULT_THEME[key];
      const color = value && _ansiStyles.default[value];
      if (color && typeof color.close === "string" && typeof color.open === "string") {
        colors[key] = color;
      } else {
        throw new Error(
          `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
        );
      }
      return colors;
    }, /* @__PURE__ */ Object.create(null));
    var getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key) => {
      colors[key] = {
        close: "",
        open: ""
      };
      return colors;
    }, /* @__PURE__ */ Object.create(null));
    var getPrintFunctionName = (options) => options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
    var getEscapeRegex = (options) => options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
    var getEscapeString = (options) => options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
    var getConfig = (options) => ({
      callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
      colors: options?.highlight ? getColorsHighlight(options) : getColorsEmpty(),
      compareKeys: typeof options?.compareKeys === "function" || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
      escapeRegex: getEscapeRegex(options),
      escapeString: getEscapeString(options),
      indent: options?.min ? "" : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
      maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
      maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
      min: options?.min ?? DEFAULT_OPTIONS.min,
      plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
      printBasicPrototype: options?.printBasicPrototype ?? true,
      printFunctionName: getPrintFunctionName(options),
      spacingInner: options?.min ? " " : "\n",
      spacingOuter: options?.min ? "" : "\n"
    });
    function createIndent(indent) {
      return new Array(indent + 1).join(" ");
    }
    function format(val, options) {
      if (options) {
        validateOptions(options);
        if (options.plugins) {
          const plugin = findPlugin(options.plugins, val);
          if (plugin !== null) {
            return printPlugin(plugin, val, getConfig(options), "", 0, []);
          }
        }
      }
      const basicResult = printBasicValue(
        val,
        getPrintFunctionName(options),
        getEscapeRegex(options),
        getEscapeString(options)
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(val, getConfig(options), "", 0, []);
    }
    var plugins = {
      AsymmetricMatcher: _AsymmetricMatcher.default,
      DOMCollection: _DOMCollection.default,
      DOMElement: _DOMElement.default,
      Immutable: _Immutable.default,
      ReactElement: _ReactElement.default,
      ReactTestComponent: _ReactTestComponent.default
    };
    exports.plugins = plugins;
    var _default = format;
    exports.default = _default;
  }
});

// node_modules/jest-diff/build/cleanupSemantic.js
var require_cleanupSemantic = __commonJS({
  "node_modules/jest-diff/build/cleanupSemantic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cleanupSemantic = exports.Diff = exports.DIFF_INSERT = exports.DIFF_EQUAL = exports.DIFF_DELETE = void 0;
    var DIFF_DELETE = -1;
    exports.DIFF_DELETE = DIFF_DELETE;
    var DIFF_INSERT = 1;
    exports.DIFF_INSERT = DIFF_INSERT;
    var DIFF_EQUAL = 0;
    exports.DIFF_EQUAL = DIFF_EQUAL;
    var Diff = class {
      0;
      1;
      constructor(op, text) {
        this[0] = op;
        this[1] = text;
      }
    };
    exports.Diff = Diff;
    var diff_commonPrefix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    var diff_commonSuffix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    var diff_commonOverlap_ = function(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    };
    var diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(
              equalities[equalitiesLength - 1],
              0,
              new Diff(DIFF_DELETE, lastEquality)
            );
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
      diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(
                pointer,
                0,
                new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))
              );
              diffs[pointer - 1][1] = deletion.substring(
                0,
                deletion.length - overlap_length1
              );
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(
                pointer,
                0,
                new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))
              );
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(
                0,
                insertion.length - overlap_length2
              );
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    exports.cleanupSemantic = diff_cleanupSemantic;
    var diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    var whitespaceRegex_ = /\s/;
    var linebreakRegex_ = /[\r\n]/;
    var blanklineEndRegex_ = /\n\r?\n$/;
    var blanklineStartRegex_ = /^\r?\n\r?\n/;
    var diff_cleanupMerge = function(diffs) {
      diffs.push(new Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(
                      0,
                      0,
                      new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))
                    );
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(
                    0,
                    text_insert.length - commonlength
                  );
                  text_delete = text_delete.substring(
                    0,
                    text_delete.length - commonlength
                  );
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(
            diffs[pointer][1].length - diffs[pointer - 1][1].length
          ) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            );
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
    };
  }
});

// node_modules/jest-diff/build/constants.js
var require_constants = __commonJS({
  "node_modules/jest-diff/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SIMILAR_MESSAGE = exports.NO_DIFF_MESSAGE = void 0;
    var NO_DIFF_MESSAGE = "Compared values have no visual difference.";
    exports.NO_DIFF_MESSAGE = NO_DIFF_MESSAGE;
    var SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
    exports.SIMILAR_MESSAGE = SIMILAR_MESSAGE;
  }
});

// node_modules/diff-sequences/build/index.js
var require_build3 = __commonJS({
  "node_modules/diff-sequences/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = diffSequence;
    var pkg = "diff-sequences";
    var NOT_YET_SET = 0;
    var countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
      let nCommon = 0;
      while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
        aIndex += 1;
        bIndex += 1;
        nCommon += 1;
      }
      return nCommon;
    };
    var countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
      let nCommon = 0;
      while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
        aIndex -= 1;
        bIndex -= 1;
        nCommon += 1;
      }
      return nCommon;
    };
    var extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
      let iF = 0;
      let kF = -d;
      let aFirst = aIndexesF[iF];
      let aIndexPrev1 = aFirst;
      aIndexesF[iF] += countCommonItemsF(
        aFirst + 1,
        aEnd,
        bF + aFirst - kF + 1,
        bEnd,
        isCommon
      );
      const nF = d < iMaxF ? d : iMaxF;
      for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
        if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
          aFirst = aIndexesF[iF];
        } else {
          aFirst = aIndexPrev1 + 1;
          if (aEnd <= aFirst) {
            return iF - 1;
          }
        }
        aIndexPrev1 = aIndexesF[iF];
        aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
      }
      return iMaxF;
    };
    var extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
      let iR = 0;
      let kR = d;
      let aFirst = aIndexesR[iR];
      let aIndexPrev1 = aFirst;
      aIndexesR[iR] -= countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
      const nR = d < iMaxR ? d : iMaxR;
      for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
        if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
          aFirst = aIndexesR[iR];
        } else {
          aFirst = aIndexPrev1 - 1;
          if (aFirst < aStart) {
            return iR - 1;
          }
        }
        aIndexPrev1 = aIndexesR[iR];
        aIndexesR[iR] = aFirst - countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bR + aFirst - kR - 1,
          isCommon
        );
      }
      return iMaxR;
    };
    var extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      const bF = bStart - aStart;
      const aLength = aEnd - aStart;
      const bLength = bEnd - bStart;
      const baDeltaLength = bLength - aLength;
      const kMinOverlapF = -baDeltaLength - (d - 1);
      const kMaxOverlapF = -baDeltaLength + (d - 1);
      let aIndexPrev1 = NOT_YET_SET;
      const nF = d < iMaxF ? d : iMaxF;
      for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
        const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];
        const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
        const aFirst = insert ? aLastPrev : aLastPrev + 1;
        const bFirst = bF + aFirst - kF;
        const nCommonF = countCommonItemsF(
          aFirst + 1,
          aEnd,
          bFirst + 1,
          bEnd,
          isCommon
        );
        const aLast = aFirst + nCommonF;
        aIndexPrev1 = aIndexesF[iF];
        aIndexesF[iF] = aLast;
        if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
          const iR = (d - 1 - (kF + baDeltaLength)) / 2;
          if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
            const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
            const nCommonR = countCommonItemsR(
              aStart,
              aLastPrev,
              bStart,
              bLastPrev,
              isCommon
            );
            const aIndexPrevFirst = aLastPrev - nCommonR;
            const bIndexPrevFirst = bLastPrev - nCommonR;
            const aEndPreceding = aIndexPrevFirst + 1;
            const bEndPreceding = bIndexPrevFirst + 1;
            division.nChangePreceding = d - 1;
            if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
              division.aEndPreceding = aStart;
              division.bEndPreceding = bStart;
            } else {
              division.aEndPreceding = aEndPreceding;
              division.bEndPreceding = bEndPreceding;
            }
            division.nCommonPreceding = nCommonR;
            if (nCommonR !== 0) {
              division.aCommonPreceding = aEndPreceding;
              division.bCommonPreceding = bEndPreceding;
            }
            division.nCommonFollowing = nCommonF;
            if (nCommonF !== 0) {
              division.aCommonFollowing = aFirst + 1;
              division.bCommonFollowing = bFirst + 1;
            }
            const aStartFollowing = aLast + 1;
            const bStartFollowing = bFirst + nCommonF + 1;
            division.nChangeFollowing = d - 1;
            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              division.aStartFollowing = aStartFollowing;
              division.bStartFollowing = bStartFollowing;
            }
            return true;
          }
        }
      }
      return false;
    };
    var extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      const bR = bEnd - aEnd;
      const aLength = aEnd - aStart;
      const bLength = bEnd - bStart;
      const baDeltaLength = bLength - aLength;
      const kMinOverlapR = baDeltaLength - d;
      const kMaxOverlapR = baDeltaLength + d;
      let aIndexPrev1 = NOT_YET_SET;
      const nR = d < iMaxR ? d : iMaxR;
      for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
        const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;
        const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
        const aFirst = insert ? aLastPrev : aLastPrev - 1;
        const bFirst = bR + aFirst - kR;
        const nCommonR = countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bFirst - 1,
          isCommon
        );
        const aLast = aFirst - nCommonR;
        aIndexPrev1 = aIndexesR[iR];
        aIndexesR[iR] = aLast;
        if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
          const iF = (d + (kR - baDeltaLength)) / 2;
          if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
            const bLast = bFirst - nCommonR;
            division.nChangePreceding = d;
            if (d === aLast + bLast - aStart - bStart) {
              division.aEndPreceding = aStart;
              division.bEndPreceding = bStart;
            } else {
              division.aEndPreceding = aLast;
              division.bEndPreceding = bLast;
            }
            division.nCommonPreceding = nCommonR;
            if (nCommonR !== 0) {
              division.aCommonPreceding = aLast;
              division.bCommonPreceding = bLast;
            }
            division.nChangeFollowing = d - 1;
            if (d === 1) {
              division.nCommonFollowing = 0;
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
              const nCommonF = countCommonItemsF(
                aLastPrev,
                aEnd,
                bLastPrev,
                bEnd,
                isCommon
              );
              division.nCommonFollowing = nCommonF;
              if (nCommonF !== 0) {
                division.aCommonFollowing = aLastPrev;
                division.bCommonFollowing = bLastPrev;
              }
              const aStartFollowing = aLastPrev + nCommonF;
              const bStartFollowing = bLastPrev + nCommonF;
              if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
                division.aStartFollowing = aEnd;
                division.bStartFollowing = bEnd;
              } else {
                division.aStartFollowing = aStartFollowing;
                division.bStartFollowing = bStartFollowing;
              }
            }
            return true;
          }
        }
      }
      return false;
    };
    var divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
      const bF = bStart - aStart;
      const bR = bEnd - aEnd;
      const aLength = aEnd - aStart;
      const bLength = bEnd - bStart;
      const baDeltaLength = bLength - aLength;
      let iMaxF = aLength;
      let iMaxR = aLength;
      aIndexesF[0] = aStart - 1;
      aIndexesR[0] = aEnd;
      if (baDeltaLength % 2 === 0) {
        const dMin = (nChange || baDeltaLength) / 2;
        const dMax = (aLength + bLength) / 2;
        for (let d = 1; d <= dMax; d += 1) {
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
          if (d < dMin) {
            iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
          } else if (
            // If a reverse path overlaps a forward path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsR(
              d,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          ) {
            return;
          }
        }
      } else {
        const dMin = ((nChange || baDeltaLength) + 1) / 2;
        const dMax = (aLength + bLength + 1) / 2;
        let d = 1;
        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        for (d += 1; d <= dMax; d += 1) {
          iMaxR = extendPathsR(
            d - 1,
            aStart,
            bStart,
            bR,
            isCommon,
            aIndexesR,
            iMaxR
          );
          if (d < dMin) {
            iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
          } else if (
            // If a forward path overlaps a reverse path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsF(
              d,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          ) {
            return;
          }
        }
      }
      throw new Error(
        `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
      );
    };
    var findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
      if (bEnd - bStart < aEnd - aStart) {
        transposed = !transposed;
        if (transposed && callbacks.length === 1) {
          const { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
          callbacks[1] = {
            foundSubsequence: (nCommon, bCommon, aCommon) => {
              foundSubsequence2(nCommon, aCommon, bCommon);
            },
            isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex)
          };
        }
        const tStart = aStart;
        const tEnd = aEnd;
        aStart = bStart;
        aEnd = bEnd;
        bStart = tStart;
        bEnd = tEnd;
      }
      const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
      divide(
        nChange,
        aStart,
        aEnd,
        bStart,
        bEnd,
        isCommon,
        aIndexesF,
        aIndexesR,
        division
      );
      const {
        nChangePreceding,
        aEndPreceding,
        bEndPreceding,
        nCommonPreceding,
        aCommonPreceding,
        bCommonPreceding,
        nCommonFollowing,
        aCommonFollowing,
        bCommonFollowing,
        nChangeFollowing,
        aStartFollowing,
        bStartFollowing
      } = division;
      if (aStart < aEndPreceding && bStart < bEndPreceding) {
        findSubsequences(
          nChangePreceding,
          aStart,
          aEndPreceding,
          bStart,
          bEndPreceding,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      }
      if (nCommonPreceding !== 0) {
        foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
      }
      if (nCommonFollowing !== 0) {
        foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
      }
      if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
        findSubsequences(
          nChangeFollowing,
          aStartFollowing,
          aEnd,
          bStartFollowing,
          bEnd,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      }
    };
    var validateLength = (name, arg) => {
      if (typeof arg !== "number") {
        throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
      }
      if (!Number.isSafeInteger(arg)) {
        throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
      }
      if (arg < 0) {
        throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
      }
    };
    var validateCallback = (name, arg) => {
      const type = typeof arg;
      if (type !== "function") {
        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
      }
    };
    function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
      validateLength("aLength", aLength);
      validateLength("bLength", bLength);
      validateCallback("isCommon", isCommon);
      validateCallback("foundSubsequence", foundSubsequence);
      const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
      if (nCommonF !== 0) {
        foundSubsequence(nCommonF, 0, 0);
      }
      if (aLength !== nCommonF || bLength !== nCommonF) {
        const aStart = nCommonF;
        const bStart = nCommonF;
        const nCommonR = countCommonItemsR(
          aStart,
          aLength - 1,
          bStart,
          bLength - 1,
          isCommon
        );
        const aEnd = aLength - nCommonR;
        const bEnd = bLength - nCommonR;
        const nCommonFR = nCommonF + nCommonR;
        if (aLength !== nCommonFR && bLength !== nCommonFR) {
          const nChange = 0;
          const transposed = false;
          const callbacks = [
            {
              foundSubsequence,
              isCommon
            }
          ];
          const aIndexesF = [NOT_YET_SET];
          const aIndexesR = [NOT_YET_SET];
          const division = {
            aCommonFollowing: NOT_YET_SET,
            aCommonPreceding: NOT_YET_SET,
            aEndPreceding: NOT_YET_SET,
            aStartFollowing: NOT_YET_SET,
            bCommonFollowing: NOT_YET_SET,
            bCommonPreceding: NOT_YET_SET,
            bEndPreceding: NOT_YET_SET,
            bStartFollowing: NOT_YET_SET,
            nChangeFollowing: NOT_YET_SET,
            nChangePreceding: NOT_YET_SET,
            nCommonFollowing: NOT_YET_SET,
            nCommonPreceding: NOT_YET_SET
          };
          findSubsequences(
            nChange,
            aStart,
            aEnd,
            bStart,
            bEnd,
            transposed,
            callbacks,
            aIndexesF,
            aIndexesR,
            division
          );
        }
        if (nCommonR !== 0) {
          foundSubsequence(nCommonR, aEnd, bEnd);
        }
      }
    }
  }
});

// node_modules/jest-diff/build/joinAlignedDiffs.js
var require_joinAlignedDiffs = __commonJS({
  "node_modules/jest-diff/build/joinAlignedDiffs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;
    var _cleanupSemantic = require_cleanupSemantic();
    var formatTrailingSpaces = (line, trailingSpaceFormatter) => line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
    var printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) => line.length !== 0 ? color(
      `${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`
    ) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
    var printDeleteLine = (line, isFirstOrLast, {
      aColor,
      aIndicator,
      changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder
    }) => printDiffLine(
      line,
      isFirstOrLast,
      aColor,
      aIndicator,
      changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder
    );
    var printInsertLine = (line, isFirstOrLast, {
      bColor,
      bIndicator,
      changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder
    }) => printDiffLine(
      line,
      isFirstOrLast,
      bColor,
      bIndicator,
      changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder
    );
    var printCommonLine = (line, isFirstOrLast, {
      commonColor,
      commonIndicator,
      commonLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder
    }) => printDiffLine(
      line,
      isFirstOrLast,
      commonColor,
      commonIndicator,
      commonLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder
    );
    var createPatchMark = (aStart, aEnd, bStart, bEnd, { patchColor }) => patchColor(
      `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`
    );
    var joinAlignedDiffsNoExpand = (diffs, options) => {
      const iLength = diffs.length;
      const nContextLines = options.contextLines;
      const nContextLines2 = nContextLines + nContextLines;
      let jLength = iLength;
      let hasExcessAtStartOrEnd = false;
      let nExcessesBetweenChanges = 0;
      let i = 0;
      while (i !== iLength) {
        const iStart = i;
        while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {
          i += 1;
        }
        if (iStart !== i) {
          if (iStart === 0) {
            if (i > nContextLines) {
              jLength -= i - nContextLines;
              hasExcessAtStartOrEnd = true;
            }
          } else if (i === iLength) {
            const n = i - iStart;
            if (n > nContextLines) {
              jLength -= n - nContextLines;
              hasExcessAtStartOrEnd = true;
            }
          } else {
            const n = i - iStart;
            if (n > nContextLines2) {
              jLength -= n - nContextLines2;
              nExcessesBetweenChanges += 1;
            }
          }
        }
        while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {
          i += 1;
        }
      }
      const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
      if (nExcessesBetweenChanges !== 0) {
        jLength += nExcessesBetweenChanges + 1;
      } else if (hasExcessAtStartOrEnd) {
        jLength += 1;
      }
      const jLast = jLength - 1;
      const lines = [];
      let jPatchMark = 0;
      if (hasPatch) {
        lines.push("");
      }
      let aStart = 0;
      let bStart = 0;
      let aEnd = 0;
      let bEnd = 0;
      const pushCommonLine = (line) => {
        const j = lines.length;
        lines.push(printCommonLine(line, j === 0 || j === jLast, options));
        aEnd += 1;
        bEnd += 1;
      };
      const pushDeleteLine = (line) => {
        const j = lines.length;
        lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
        aEnd += 1;
      };
      const pushInsertLine = (line) => {
        const j = lines.length;
        lines.push(printInsertLine(line, j === 0 || j === jLast, options));
        bEnd += 1;
      };
      i = 0;
      while (i !== iLength) {
        let iStart = i;
        while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {
          i += 1;
        }
        if (iStart !== i) {
          if (iStart === 0) {
            if (i > nContextLines) {
              iStart = i - nContextLines;
              aStart = iStart;
              bStart = iStart;
              aEnd = aStart;
              bEnd = bStart;
            }
            for (let iCommon = iStart; iCommon !== i; iCommon += 1) {
              pushCommonLine(diffs[iCommon][1]);
            }
          } else if (i === iLength) {
            const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
            for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
              pushCommonLine(diffs[iCommon][1]);
            }
          } else {
            const nCommon = i - iStart;
            if (nCommon > nContextLines2) {
              const iEnd = iStart + nContextLines;
              for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
                pushCommonLine(diffs[iCommon][1]);
              }
              lines[jPatchMark] = createPatchMark(
                aStart,
                aEnd,
                bStart,
                bEnd,
                options
              );
              jPatchMark = lines.length;
              lines.push("");
              const nOmit = nCommon - nContextLines2;
              aStart = aEnd + nOmit;
              bStart = bEnd + nOmit;
              aEnd = aStart;
              bEnd = bStart;
              for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {
                pushCommonLine(diffs[iCommon][1]);
              }
            } else {
              for (let iCommon = iStart; iCommon !== i; iCommon += 1) {
                pushCommonLine(diffs[iCommon][1]);
              }
            }
          }
        }
        while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {
          pushDeleteLine(diffs[i][1]);
          i += 1;
        }
        while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {
          pushInsertLine(diffs[i][1]);
          i += 1;
        }
      }
      if (hasPatch) {
        lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
      }
      return lines.join("\n");
    };
    exports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;
    var joinAlignedDiffsExpand = (diffs, options) => diffs.map((diff, i, diffs2) => {
      const line = diff[1];
      const isFirstOrLast = i === 0 || i === diffs2.length - 1;
      switch (diff[0]) {
        case _cleanupSemantic.DIFF_DELETE:
          return printDeleteLine(line, isFirstOrLast, options);
        case _cleanupSemantic.DIFF_INSERT:
          return printInsertLine(line, isFirstOrLast, options);
        default:
          return printCommonLine(line, isFirstOrLast, options);
      }
    }).join("\n");
    exports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;
  }
});

// node_modules/jest-diff/build/normalizeDiffOptions.js
var require_normalizeDiffOptions = __commonJS({
  "node_modules/jest-diff/build/normalizeDiffOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.normalizeDiffOptions = exports.noColor = void 0;
    var _chalk = _interopRequireDefault(require_source());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var noColor = (string) => string;
    exports.noColor = noColor;
    var DIFF_CONTEXT_DEFAULT = 5;
    var OPTIONS_DEFAULT = {
      aAnnotation: "Expected",
      aColor: _chalk.default.green,
      aIndicator: "-",
      bAnnotation: "Received",
      bColor: _chalk.default.red,
      bIndicator: "+",
      changeColor: _chalk.default.inverse,
      changeLineTrailingSpaceColor: noColor,
      commonColor: _chalk.default.dim,
      commonIndicator: " ",
      commonLineTrailingSpaceColor: noColor,
      compareKeys: void 0,
      contextLines: DIFF_CONTEXT_DEFAULT,
      emptyFirstOrLastLinePlaceholder: "",
      expand: true,
      includeChangeCounts: false,
      omitAnnotationLines: false,
      patchColor: _chalk.default.yellow
    };
    var getCompareKeys = (compareKeys) => compareKeys && typeof compareKeys === "function" ? compareKeys : OPTIONS_DEFAULT.compareKeys;
    var getContextLines = (contextLines) => typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
    var normalizeDiffOptions = (options = {}) => ({
      ...OPTIONS_DEFAULT,
      ...options,
      compareKeys: getCompareKeys(options.compareKeys),
      contextLines: getContextLines(options.contextLines)
    });
    exports.normalizeDiffOptions = normalizeDiffOptions;
  }
});

// node_modules/jest-diff/build/diffLines.js
var require_diffLines = __commonJS({
  "node_modules/jest-diff/build/diffLines.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printDiffLines = exports.diffLinesUnified2 = exports.diffLinesUnified = exports.diffLinesRaw = void 0;
    var _diffSequences = _interopRequireDefault(require_build3());
    var _cleanupSemantic = require_cleanupSemantic();
    var _joinAlignedDiffs = require_joinAlignedDiffs();
    var _normalizeDiffOptions = require_normalizeDiffOptions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isEmptyString = (lines) => lines.length === 1 && lines[0].length === 0;
    var countChanges = (diffs) => {
      let a = 0;
      let b = 0;
      diffs.forEach((diff) => {
        switch (diff[0]) {
          case _cleanupSemantic.DIFF_DELETE:
            a += 1;
            break;
          case _cleanupSemantic.DIFF_INSERT:
            b += 1;
            break;
        }
      });
      return {
        a,
        b
      };
    };
    var printAnnotation = ({
      aAnnotation,
      aColor,
      aIndicator,
      bAnnotation,
      bColor,
      bIndicator,
      includeChangeCounts,
      omitAnnotationLines
    }, changeCounts) => {
      if (omitAnnotationLines) {
        return "";
      }
      let aRest = "";
      let bRest = "";
      if (includeChangeCounts) {
        const aCount = String(changeCounts.a);
        const bCount = String(changeCounts.b);
        const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
        const aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
        const bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
        const baCountLengthDiff = bCount.length - aCount.length;
        const aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
        const bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
        aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
        bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
      }
      const a = `${aIndicator} ${aAnnotation}${aRest}`;
      const b = `${bIndicator} ${bAnnotation}${bRest}`;
      return `${aColor(a)}
${bColor(b)}

`;
    };
    var printDiffLines = (diffs, options) => printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options));
    exports.printDiffLines = printDiffLines;
    var diffLinesUnified = (aLines, bLines, options) => printDiffLines(
      diffLinesRaw(
        isEmptyString(aLines) ? [] : aLines,
        isEmptyString(bLines) ? [] : bLines
      ),
      (0, _normalizeDiffOptions.normalizeDiffOptions)(options)
    );
    exports.diffLinesUnified = diffLinesUnified;
    var diffLinesUnified2 = (aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) => {
      if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
        aLinesDisplay = [];
        aLinesCompare = [];
      }
      if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
        bLinesDisplay = [];
        bLinesCompare = [];
      }
      if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
        return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
      }
      const diffs = diffLinesRaw(aLinesCompare, bLinesCompare);
      let aIndex = 0;
      let bIndex = 0;
      diffs.forEach((diff) => {
        switch (diff[0]) {
          case _cleanupSemantic.DIFF_DELETE:
            diff[1] = aLinesDisplay[aIndex];
            aIndex += 1;
            break;
          case _cleanupSemantic.DIFF_INSERT:
            diff[1] = bLinesDisplay[bIndex];
            bIndex += 1;
            break;
          default:
            diff[1] = bLinesDisplay[bIndex];
            aIndex += 1;
            bIndex += 1;
        }
      });
      return printDiffLines(
        diffs,
        (0, _normalizeDiffOptions.normalizeDiffOptions)(options)
      );
    };
    exports.diffLinesUnified2 = diffLinesUnified2;
    var diffLinesRaw = (aLines, bLines) => {
      const aLength = aLines.length;
      const bLength = bLines.length;
      const isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2];
      const diffs = [];
      let aIndex = 0;
      let bIndex = 0;
      const foundSubsequence = (nCommon, aCommon, bCommon) => {
        for (; aIndex !== aCommon; aIndex += 1) {
          diffs.push(
            new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex])
          );
        }
        for (; bIndex !== bCommon; bIndex += 1) {
          diffs.push(
            new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex])
          );
        }
        for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {
          diffs.push(
            new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex])
          );
        }
      };
      (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence);
      for (; aIndex !== aLength; aIndex += 1) {
        diffs.push(
          new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex])
        );
      }
      for (; bIndex !== bLength; bIndex += 1) {
        diffs.push(
          new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex])
        );
      }
      return diffs;
    };
    exports.diffLinesRaw = diffLinesRaw;
  }
});

// node_modules/jest-diff/build/diffStrings.js
var require_diffStrings = __commonJS({
  "node_modules/jest-diff/build/diffStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _diffSequences = _interopRequireDefault(require_build3());
    var _cleanupSemantic = require_cleanupSemantic();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var diffStrings = (a, b) => {
      const isCommon = (aIndex2, bIndex2) => a[aIndex2] === b[bIndex2];
      let aIndex = 0;
      let bIndex = 0;
      const diffs = [];
      const foundSubsequence = (nCommon, aCommon, bCommon) => {
        if (aIndex !== aCommon) {
          diffs.push(
            new _cleanupSemantic.Diff(
              _cleanupSemantic.DIFF_DELETE,
              a.slice(aIndex, aCommon)
            )
          );
        }
        if (bIndex !== bCommon) {
          diffs.push(
            new _cleanupSemantic.Diff(
              _cleanupSemantic.DIFF_INSERT,
              b.slice(bIndex, bCommon)
            )
          );
        }
        aIndex = aCommon + nCommon;
        bIndex = bCommon + nCommon;
        diffs.push(
          new _cleanupSemantic.Diff(
            _cleanupSemantic.DIFF_EQUAL,
            b.slice(bCommon, bIndex)
          )
        );
      };
      (0, _diffSequences.default)(a.length, b.length, isCommon, foundSubsequence);
      if (aIndex !== a.length) {
        diffs.push(
          new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, a.slice(aIndex))
        );
      }
      if (bIndex !== b.length) {
        diffs.push(
          new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, b.slice(bIndex))
        );
      }
      return diffs;
    };
    var _default = diffStrings;
    exports.default = _default;
  }
});

// node_modules/jest-diff/build/getAlignedDiffs.js
var require_getAlignedDiffs = __commonJS({
  "node_modules/jest-diff/build/getAlignedDiffs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _cleanupSemantic = require_cleanupSemantic();
    var concatenateRelevantDiffs = (op, diffs, changeColor) => diffs.reduce(
      (reduced, diff) => reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 ? changeColor(diff[1]) : ""),
      ""
    );
    var ChangeBuffer = class {
      op;
      line;
      // incomplete line
      lines;
      // complete lines
      changeColor;
      constructor(op, changeColor) {
        this.op = op;
        this.line = [];
        this.lines = [];
        this.changeColor = changeColor;
      }
      pushSubstring(substring) {
        this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));
      }
      pushLine() {
        this.lines.push(
          this.line.length !== 1 ? new _cleanupSemantic.Diff(
            this.op,
            concatenateRelevantDiffs(this.op, this.line, this.changeColor)
          ) : this.line[0][0] === this.op ? this.line[0] : new _cleanupSemantic.Diff(this.op, this.line[0][1])
          // was common diff
        );
        this.line.length = 0;
      }
      isLineEmpty() {
        return this.line.length === 0;
      }
      // Minor input to buffer.
      pushDiff(diff) {
        this.line.push(diff);
      }
      // Main input to buffer.
      align(diff) {
        const string = diff[1];
        if (string.includes("\n")) {
          const substrings = string.split("\n");
          const iLast = substrings.length - 1;
          substrings.forEach((substring, i) => {
            if (i < iLast) {
              this.pushSubstring(substring);
              this.pushLine();
            } else if (substring.length !== 0) {
              this.pushSubstring(substring);
            }
          });
        } else {
          this.pushDiff(diff);
        }
      }
      // Output from buffer.
      moveLinesTo(lines) {
        if (!this.isLineEmpty()) {
          this.pushLine();
        }
        lines.push(...this.lines);
        this.lines.length = 0;
      }
    };
    var CommonBuffer = class {
      deleteBuffer;
      insertBuffer;
      lines;
      constructor(deleteBuffer, insertBuffer) {
        this.deleteBuffer = deleteBuffer;
        this.insertBuffer = insertBuffer;
        this.lines = [];
      }
      pushDiffCommonLine(diff) {
        this.lines.push(diff);
      }
      pushDiffChangeLines(diff) {
        const isDiffEmpty = diff[1].length === 0;
        if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {
          this.deleteBuffer.pushDiff(diff);
        }
        if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {
          this.insertBuffer.pushDiff(diff);
        }
      }
      flushChangeLines() {
        this.deleteBuffer.moveLinesTo(this.lines);
        this.insertBuffer.moveLinesTo(this.lines);
      }
      // Input to buffer.
      align(diff) {
        const op = diff[0];
        const string = diff[1];
        if (string.includes("\n")) {
          const substrings = string.split("\n");
          const iLast = substrings.length - 1;
          substrings.forEach((substring, i) => {
            if (i === 0) {
              const subdiff = new _cleanupSemantic.Diff(op, substring);
              if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
                this.flushChangeLines();
                this.pushDiffCommonLine(subdiff);
              } else {
                this.pushDiffChangeLines(subdiff);
                this.flushChangeLines();
              }
            } else if (i < iLast) {
              this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));
            } else if (substring.length !== 0) {
              this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));
            }
          });
        } else {
          this.pushDiffChangeLines(diff);
        }
      }
      // Output from buffer.
      getLines() {
        this.flushChangeLines();
        return this.lines;
      }
    };
    var getAlignedDiffs = (diffs, changeColor) => {
      const deleteBuffer = new ChangeBuffer(
        _cleanupSemantic.DIFF_DELETE,
        changeColor
      );
      const insertBuffer = new ChangeBuffer(
        _cleanupSemantic.DIFF_INSERT,
        changeColor
      );
      const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
      diffs.forEach((diff) => {
        switch (diff[0]) {
          case _cleanupSemantic.DIFF_DELETE:
            deleteBuffer.align(diff);
            break;
          case _cleanupSemantic.DIFF_INSERT:
            insertBuffer.align(diff);
            break;
          default:
            commonBuffer.align(diff);
        }
      });
      return commonBuffer.getLines();
    };
    var _default = getAlignedDiffs;
    exports.default = _default;
  }
});

// node_modules/jest-diff/build/printDiffs.js
var require_printDiffs = __commonJS({
  "node_modules/jest-diff/build/printDiffs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffStringsUnified = exports.diffStringsRaw = void 0;
    var _cleanupSemantic = require_cleanupSemantic();
    var _diffLines = require_diffLines();
    var _diffStrings = _interopRequireDefault(require_diffStrings());
    var _getAlignedDiffs = _interopRequireDefault(require_getAlignedDiffs());
    var _normalizeDiffOptions = require_normalizeDiffOptions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasCommonDiff = (diffs, isMultiline) => {
      if (isMultiline) {
        const iLast = diffs.length - 1;
        return diffs.some(
          (diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== "\n")
        );
      }
      return diffs.some((diff) => diff[0] === _cleanupSemantic.DIFF_EQUAL);
    };
    var diffStringsUnified = (a, b, options) => {
      if (a !== b && a.length !== 0 && b.length !== 0) {
        const isMultiline = a.includes("\n") || b.includes("\n");
        const diffs = diffStringsRaw(
          isMultiline ? `${a}
` : a,
          isMultiline ? `${b}
` : b,
          true
          // cleanupSemantic
        );
        if (hasCommonDiff(diffs, isMultiline)) {
          const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(
            options
          );
          const lines = (0, _getAlignedDiffs.default)(
            diffs,
            optionsNormalized.changeColor
          );
          return (0, _diffLines.printDiffLines)(lines, optionsNormalized);
        }
      }
      return (0, _diffLines.diffLinesUnified)(
        a.split("\n"),
        b.split("\n"),
        options
      );
    };
    exports.diffStringsUnified = diffStringsUnified;
    var diffStringsRaw = (a, b, cleanup) => {
      const diffs = (0, _diffStrings.default)(a, b);
      if (cleanup) {
        (0, _cleanupSemantic.cleanupSemantic)(diffs);
      }
      return diffs;
    };
    exports.diffStringsRaw = diffStringsRaw;
  }
});

// node_modules/jest-diff/build/index.js
var require_build4 = __commonJS({
  "node_modules/jest-diff/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DIFF_DELETE", {
      enumerable: true,
      get: function() {
        return _cleanupSemantic.DIFF_DELETE;
      }
    });
    Object.defineProperty(exports, "DIFF_EQUAL", {
      enumerable: true,
      get: function() {
        return _cleanupSemantic.DIFF_EQUAL;
      }
    });
    Object.defineProperty(exports, "DIFF_INSERT", {
      enumerable: true,
      get: function() {
        return _cleanupSemantic.DIFF_INSERT;
      }
    });
    Object.defineProperty(exports, "Diff", {
      enumerable: true,
      get: function() {
        return _cleanupSemantic.Diff;
      }
    });
    exports.diff = diff;
    Object.defineProperty(exports, "diffLinesRaw", {
      enumerable: true,
      get: function() {
        return _diffLines.diffLinesRaw;
      }
    });
    Object.defineProperty(exports, "diffLinesUnified", {
      enumerable: true,
      get: function() {
        return _diffLines.diffLinesUnified;
      }
    });
    Object.defineProperty(exports, "diffLinesUnified2", {
      enumerable: true,
      get: function() {
        return _diffLines.diffLinesUnified2;
      }
    });
    Object.defineProperty(exports, "diffStringsRaw", {
      enumerable: true,
      get: function() {
        return _printDiffs.diffStringsRaw;
      }
    });
    Object.defineProperty(exports, "diffStringsUnified", {
      enumerable: true,
      get: function() {
        return _printDiffs.diffStringsUnified;
      }
    });
    var _chalk = _interopRequireDefault(require_source());
    var _jestGetType = require_build();
    var _prettyFormat = require_build2();
    var _cleanupSemantic = require_cleanupSemantic();
    var _constants = require_constants();
    var _diffLines = require_diffLines();
    var _normalizeDiffOptions = require_normalizeDiffOptions();
    var _printDiffs = require_printDiffs();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Symbol2 = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
    var getCommonMessage = (message, options) => {
      const { commonColor } = (0, _normalizeDiffOptions.normalizeDiffOptions)(
        options
      );
      return commonColor(message);
    };
    var {
      AsymmetricMatcher,
      DOMCollection,
      DOMElement,
      Immutable,
      ReactElement,
      ReactTestComponent
    } = _prettyFormat.plugins;
    var PLUGINS = [
      ReactTestComponent,
      ReactElement,
      DOMElement,
      DOMCollection,
      Immutable,
      AsymmetricMatcher
    ];
    var FORMAT_OPTIONS = {
      plugins: PLUGINS
    };
    var FALLBACK_FORMAT_OPTIONS = {
      callToJSON: false,
      maxDepth: 10,
      plugins: PLUGINS
    };
    function diff(a, b, options) {
      if (Object.is(a, b)) {
        return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
      }
      const aType = (0, _jestGetType.getType)(a);
      let expectedType = aType;
      let omitDifference = false;
      if (aType === "object" && typeof a.asymmetricMatch === "function") {
        if (a.$$typeof !== Symbol2.for("jest.asymmetricMatcher")) {
          return null;
        }
        if (typeof a.getExpectedType !== "function") {
          return null;
        }
        expectedType = a.getExpectedType();
        omitDifference = expectedType === "string";
      }
      if (expectedType !== (0, _jestGetType.getType)(b)) {
        return `  Comparing two different types of values. Expected ${_chalk.default.green(expectedType)} but received ${_chalk.default.red((0, _jestGetType.getType)(b))}.`;
      }
      if (omitDifference) {
        return null;
      }
      switch (aType) {
        case "string":
          return (0, _diffLines.diffLinesUnified)(
            a.split("\n"),
            b.split("\n"),
            options
          );
        case "boolean":
        case "number":
          return comparePrimitive(a, b, options);
        case "map":
          return compareObjects(sortMap(a), sortMap(b), options);
        case "set":
          return compareObjects(sortSet(a), sortSet(b), options);
        default:
          return compareObjects(a, b, options);
      }
    }
    function comparePrimitive(a, b, options) {
      const aFormat = (0, _prettyFormat.format)(a, FORMAT_OPTIONS);
      const bFormat = (0, _prettyFormat.format)(b, FORMAT_OPTIONS);
      return aFormat === bFormat ? getCommonMessage(_constants.NO_DIFF_MESSAGE, options) : (0, _diffLines.diffLinesUnified)(
        aFormat.split("\n"),
        bFormat.split("\n"),
        options
      );
    }
    function sortMap(map) {
      return new Map(Array.from(map.entries()).sort());
    }
    function sortSet(set) {
      return new Set(Array.from(set.values()).sort());
    }
    function compareObjects(a, b, options) {
      let difference;
      let hasThrown = false;
      try {
        const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
        difference = getObjectsDifference(a, b, formatOptions, options);
      } catch {
        hasThrown = true;
      }
      const noDiffMessage = getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
      if (difference === void 0 || difference === noDiffMessage) {
        const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
        difference = getObjectsDifference(a, b, formatOptions, options);
        if (difference !== noDiffMessage && !hasThrown) {
          difference = `${getCommonMessage(
            _constants.SIMILAR_MESSAGE,
            options
          )}

${difference}`;
        }
      }
      return difference;
    }
    function getFormatOptions(formatOptions, options) {
      const { compareKeys } = (0, _normalizeDiffOptions.normalizeDiffOptions)(
        options
      );
      return {
        ...formatOptions,
        compareKeys
      };
    }
    function getObjectsDifference(a, b, formatOptions, options) {
      const formatOptionsZeroIndent = {
        ...formatOptions,
        indent: 0
      };
      const aCompare = (0, _prettyFormat.format)(a, formatOptionsZeroIndent);
      const bCompare = (0, _prettyFormat.format)(b, formatOptionsZeroIndent);
      if (aCompare === bCompare) {
        return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);
      } else {
        const aDisplay = (0, _prettyFormat.format)(a, formatOptions);
        const bDisplay = (0, _prettyFormat.format)(b, formatOptions);
        return (0, _diffLines.diffLinesUnified2)(
          aDisplay.split("\n"),
          bDisplay.split("\n"),
          aCompare.split("\n"),
          bCompare.split("\n"),
          options
        );
      }
    }
  }
});

// node_modules/jest-matcher-utils/build/Replaceable.js
var require_Replaceable = __commonJS({
  "node_modules/jest-matcher-utils/build/Replaceable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _jestGetType = require_build();
    var supportTypes = ["map", "array", "object"];
    var Replaceable = class {
      object;
      type;
      constructor(object) {
        this.object = object;
        this.type = (0, _jestGetType.getType)(object);
        if (!supportTypes.includes(this.type)) {
          throw new Error(`Type ${this.type} is not support in Replaceable!`);
        }
      }
      static isReplaceable(obj1, obj2) {
        const obj1Type = (0, _jestGetType.getType)(obj1);
        const obj2Type = (0, _jestGetType.getType)(obj2);
        return obj1Type === obj2Type && supportTypes.includes(obj1Type);
      }
      forEach(cb) {
        if (this.type === "object") {
          const descriptors = Object.getOwnPropertyDescriptors(this.object);
          [
            ...Object.keys(descriptors),
            ...Object.getOwnPropertySymbols(descriptors)
          ].filter((key) => descriptors[key].enumerable).forEach((key) => {
            cb(this.object[key], key, this.object);
          });
        } else {
          this.object.forEach(cb);
        }
      }
      get(key) {
        if (this.type === "map") {
          return this.object.get(key);
        }
        return this.object[key];
      }
      set(key, value) {
        if (this.type === "map") {
          this.object.set(key, value);
        } else {
          this.object[key] = value;
        }
      }
    };
    exports.default = Replaceable;
  }
});

// node_modules/jest-matcher-utils/build/deepCyclicCopyReplaceable.js
var require_deepCyclicCopyReplaceable = __commonJS({
  "node_modules/jest-matcher-utils/build/deepCyclicCopyReplaceable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deepCyclicCopyReplaceable;
    var _prettyFormat = require_build2();
    var builtInObject = [
      Array,
      Date,
      Float32Array,
      Float64Array,
      Int16Array,
      Int32Array,
      Int8Array,
      Map,
      Set,
      RegExp,
      Uint16Array,
      Uint32Array,
      Uint8Array,
      Uint8ClampedArray
    ];
    if (typeof Buffer !== "undefined") {
      builtInObject.push(Buffer);
    }
    var isBuiltInObject = (object) => builtInObject.includes(object.constructor);
    var isMap = (value) => value.constructor === Map;
    function deepCyclicCopyReplaceable(value, cycles = /* @__PURE__ */ new WeakMap()) {
      if (typeof value !== "object" || value === null) {
        return value;
      } else if (cycles.has(value)) {
        return cycles.get(value);
      } else if (Array.isArray(value)) {
        return deepCyclicCopyArray(value, cycles);
      } else if (isMap(value)) {
        return deepCyclicCopyMap(value, cycles);
      } else if (isBuiltInObject(value)) {
        return value;
      } else if (_prettyFormat.plugins.DOMElement.test(value)) {
        return value.cloneNode(true);
      } else {
        return deepCyclicCopyObject(value, cycles);
      }
    }
    function deepCyclicCopyObject(object, cycles) {
      const newObject = Object.create(Object.getPrototypeOf(object));
      let descriptors = {};
      let obj = object;
      do {
        descriptors = Object.assign(
          {},
          Object.getOwnPropertyDescriptors(obj),
          descriptors
        );
      } while ((obj = Object.getPrototypeOf(obj)) && obj !== Object.getPrototypeOf({}));
      cycles.set(object, newObject);
      const newDescriptors = [
        ...Object.keys(descriptors),
        ...Object.getOwnPropertySymbols(descriptors)
      ].reduce(
        //@ts-expect-error because typescript do not support symbol key in object
        //https://github.com/microsoft/TypeScript/issues/1863
        (newDescriptors2, key) => {
          const enumerable = descriptors[key].enumerable;
          newDescriptors2[key] = {
            configurable: true,
            enumerable,
            value: deepCyclicCopyReplaceable(
              // this accesses the value or getter, depending. We just care about the value anyways, and this allows us to not mess with accessors
              // it has the side effect of invoking the getter here though, rather than copying it over
              object[key],
              cycles
            ),
            writable: true
          };
          return newDescriptors2;
        },
        {}
      );
      return Object.defineProperties(newObject, newDescriptors);
    }
    function deepCyclicCopyArray(array, cycles) {
      const newArray = new (Object.getPrototypeOf(array)).constructor(array.length);
      const length = array.length;
      cycles.set(array, newArray);
      for (let i = 0; i < length; i++) {
        newArray[i] = deepCyclicCopyReplaceable(array[i], cycles);
      }
      return newArray;
    }
    function deepCyclicCopyMap(map, cycles) {
      const newMap = /* @__PURE__ */ new Map();
      cycles.set(map, newMap);
      map.forEach((value, key) => {
        newMap.set(key, deepCyclicCopyReplaceable(value, cycles));
      });
      return newMap;
    }
  }
});

// node_modules/jest-matcher-utils/build/index.js
var require_build5 = __commonJS({
  "node_modules/jest-matcher-utils/build/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printReceived = exports.printExpected = exports.printDiffOrStringify = exports.pluralize = exports.matcherHint = exports.matcherErrorMessage = exports.highlightTrailingWhitespace = exports.getLabelPrinter = exports.ensureNumbers = exports.ensureNoExpected = exports.ensureExpectedIsNumber = exports.ensureExpectedIsNonNegativeInteger = exports.ensureActualIsNumber = exports.diff = exports.SUGGEST_TO_CONTAIN_EQUAL = exports.RECEIVED_COLOR = exports.INVERTED_COLOR = exports.EXPECTED_COLOR = exports.DIM_COLOR = exports.BOLD_WEIGHT = void 0;
    exports.printWithType = printWithType;
    exports.replaceMatchedToAsymmetricMatcher = replaceMatchedToAsymmetricMatcher;
    exports.stringify = void 0;
    var _chalk = _interopRequireDefault(require_source());
    var _jestDiff = require_build4();
    var _jestGetType = require_build();
    var _prettyFormat = require_build2();
    var _Replaceable = _interopRequireDefault(require_Replaceable());
    var _deepCyclicCopyReplaceable = _interopRequireDefault(
      require_deepCyclicCopyReplaceable()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      AsymmetricMatcher,
      DOMCollection,
      DOMElement,
      Immutable,
      ReactElement,
      ReactTestComponent
    } = _prettyFormat.plugins;
    var PLUGINS = [
      ReactTestComponent,
      ReactElement,
      DOMElement,
      DOMCollection,
      Immutable,
      AsymmetricMatcher
    ];
    var EXPECTED_COLOR = _chalk.default.green;
    exports.EXPECTED_COLOR = EXPECTED_COLOR;
    var RECEIVED_COLOR = _chalk.default.red;
    exports.RECEIVED_COLOR = RECEIVED_COLOR;
    var INVERTED_COLOR = _chalk.default.inverse;
    exports.INVERTED_COLOR = INVERTED_COLOR;
    var BOLD_WEIGHT = _chalk.default.bold;
    exports.BOLD_WEIGHT = BOLD_WEIGHT;
    var DIM_COLOR = _chalk.default.dim;
    exports.DIM_COLOR = DIM_COLOR;
    var MULTILINE_REGEXP = /\n/;
    var SPACE_SYMBOL = "·";
    var NUMBERS = [
      "zero",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "ten",
      "eleven",
      "twelve",
      "thirteen"
    ];
    var SUGGEST_TO_CONTAIN_EQUAL = _chalk.default.dim(
      "Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead."
    );
    exports.SUGGEST_TO_CONTAIN_EQUAL = SUGGEST_TO_CONTAIN_EQUAL;
    var stringify = (object, maxDepth = 10, maxWidth = 10) => {
      const MAX_LENGTH = 1e4;
      let result;
      try {
        result = (0, _prettyFormat.format)(object, {
          maxDepth,
          maxWidth,
          min: true,
          plugins: PLUGINS
        });
      } catch {
        result = (0, _prettyFormat.format)(object, {
          callToJSON: false,
          maxDepth,
          maxWidth,
          min: true,
          plugins: PLUGINS
        });
      }
      if (result.length >= MAX_LENGTH && maxDepth > 1) {
        return stringify(object, Math.floor(maxDepth / 2), maxWidth);
      } else if (result.length >= MAX_LENGTH && maxWidth > 1) {
        return stringify(object, maxDepth, Math.floor(maxWidth / 2));
      } else {
        return result;
      }
    };
    exports.stringify = stringify;
    var highlightTrailingWhitespace = (text) => text.replace(/\s+$/gm, _chalk.default.inverse("$&"));
    exports.highlightTrailingWhitespace = highlightTrailingWhitespace;
    var replaceTrailingSpaces = (text) => text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
    var printReceived = (object) => RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));
    exports.printReceived = printReceived;
    var printExpected = (value) => EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));
    exports.printExpected = printExpected;
    function printWithType(name, value, print) {
      const type = (0, _jestGetType.getType)(value);
      const hasType = type !== "null" && type !== "undefined" ? `${name} has type:  ${type}
` : "";
      const hasValue = `${name} has value: ${print(value)}`;
      return hasType + hasValue;
    }
    var ensureNoExpected = (expected, matcherName, options) => {
      if (typeof expected !== "undefined") {
        const matcherString = (options ? "" : "[.not]") + matcherName;
        throw new Error(
          matcherErrorMessage(
            matcherHint(matcherString, void 0, "", options),
            // Because expected is omitted in hint above,
            // expected is black instead of green in message below.
            "this matcher must not have an expected argument",
            printWithType("Expected", expected, printExpected)
          )
        );
      }
    };
    exports.ensureNoExpected = ensureNoExpected;
    var ensureActualIsNumber = (actual, matcherName, options) => {
      if (typeof actual !== "number" && typeof actual !== "bigint") {
        const matcherString = (options ? "" : "[.not]") + matcherName;
        throw new Error(
          matcherErrorMessage(
            matcherHint(matcherString, void 0, void 0, options),
            `${RECEIVED_COLOR("received")} value must be a number or bigint`,
            printWithType("Received", actual, printReceived)
          )
        );
      }
    };
    exports.ensureActualIsNumber = ensureActualIsNumber;
    var ensureExpectedIsNumber = (expected, matcherName, options) => {
      if (typeof expected !== "number" && typeof expected !== "bigint") {
        const matcherString = (options ? "" : "[.not]") + matcherName;
        throw new Error(
          matcherErrorMessage(
            matcherHint(matcherString, void 0, void 0, options),
            `${EXPECTED_COLOR("expected")} value must be a number or bigint`,
            printWithType("Expected", expected, printExpected)
          )
        );
      }
    };
    exports.ensureExpectedIsNumber = ensureExpectedIsNumber;
    var ensureNumbers = (actual, expected, matcherName, options) => {
      ensureActualIsNumber(actual, matcherName, options);
      ensureExpectedIsNumber(expected, matcherName, options);
    };
    exports.ensureNumbers = ensureNumbers;
    var ensureExpectedIsNonNegativeInteger = (expected, matcherName, options) => {
      if (typeof expected !== "number" || !Number.isSafeInteger(expected) || expected < 0) {
        const matcherString = (options ? "" : "[.not]") + matcherName;
        throw new Error(
          matcherErrorMessage(
            matcherHint(matcherString, void 0, void 0, options),
            `${EXPECTED_COLOR("expected")} value must be a non-negative integer`,
            printWithType("Expected", expected, printExpected)
          )
        );
      }
    };
    exports.ensureExpectedIsNonNegativeInteger = ensureExpectedIsNonNegativeInteger;
    var getCommonAndChangedSubstrings = (diffs, op, hasCommonDiff) => diffs.reduce(
      (reduced, diff2) => reduced + (diff2[0] === _jestDiff.DIFF_EQUAL ? diff2[1] : diff2[0] !== op ? "" : hasCommonDiff ? INVERTED_COLOR(diff2[1]) : diff2[1]),
      ""
    );
    var isLineDiffable = (expected, received) => {
      const expectedType = (0, _jestGetType.getType)(expected);
      const receivedType = (0, _jestGetType.getType)(received);
      if (expectedType !== receivedType) {
        return false;
      }
      if ((0, _jestGetType.isPrimitive)(expected)) {
        return typeof expected === "string" && typeof received === "string" && expected.length !== 0 && received.length !== 0 && (MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received));
      }
      if (expectedType === "date" || expectedType === "function" || expectedType === "regexp") {
        return false;
      }
      if (expected instanceof Error && received instanceof Error) {
        return false;
      }
      if (receivedType === "object" && typeof received.asymmetricMatch === "function") {
        return false;
      }
      return true;
    };
    var MAX_DIFF_STRING_LENGTH = 2e4;
    var printDiffOrStringify = (expected, received, expectedLabel, receivedLabel, expand) => {
      if (typeof expected === "string" && typeof received === "string" && expected.length !== 0 && received.length !== 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
        if (expected.includes("\n") || received.includes("\n")) {
          return (0, _jestDiff.diffStringsUnified)(expected, received, {
            aAnnotation: expectedLabel,
            bAnnotation: receivedLabel,
            changeLineTrailingSpaceColor: _chalk.default.bgYellow,
            commonLineTrailingSpaceColor: _chalk.default.bgYellow,
            emptyFirstOrLastLinePlaceholder: "↵",
            // U+21B5
            expand,
            includeChangeCounts: true
          });
        }
        const diffs = (0, _jestDiff.diffStringsRaw)(expected, received, true);
        const hasCommonDiff = diffs.some((diff2) => diff2[0] === _jestDiff.DIFF_EQUAL);
        const printLabel2 = getLabelPrinter(expectedLabel, receivedLabel);
        const expectedLine2 = printLabel2(expectedLabel) + printExpected(
          getCommonAndChangedSubstrings(
            diffs,
            _jestDiff.DIFF_DELETE,
            hasCommonDiff
          )
        );
        const receivedLine2 = printLabel2(receivedLabel) + printReceived(
          getCommonAndChangedSubstrings(
            diffs,
            _jestDiff.DIFF_INSERT,
            hasCommonDiff
          )
        );
        return `${expectedLine2}
${receivedLine2}`;
      }
      if (isLineDiffable(expected, received)) {
        const { replacedExpected, replacedReceived } = replaceMatchedToAsymmetricMatcher(expected, received, [], []);
        const difference = (0, _jestDiff.diff)(replacedExpected, replacedReceived, {
          aAnnotation: expectedLabel,
          bAnnotation: receivedLabel,
          expand,
          includeChangeCounts: true
        });
        if (typeof difference === "string" && difference.includes(`- ${expectedLabel}`) && difference.includes(`+ ${receivedLabel}`)) {
          return difference;
        }
      }
      const printLabel = getLabelPrinter(expectedLabel, receivedLabel);
      const expectedLine = printLabel(expectedLabel) + printExpected(expected);
      const receivedLine = printLabel(receivedLabel) + (stringify(expected) === stringify(received) ? "serializes to the same string" : printReceived(received));
      return `${expectedLine}
${receivedLine}`;
    };
    exports.printDiffOrStringify = printDiffOrStringify;
    var shouldPrintDiff = (actual, expected) => {
      if (typeof actual === "number" && typeof expected === "number") {
        return false;
      }
      if (typeof actual === "bigint" && typeof expected === "bigint") {
        return false;
      }
      if (typeof actual === "boolean" && typeof expected === "boolean") {
        return false;
      }
      return true;
    };
    function replaceMatchedToAsymmetricMatcher(replacedExpected, replacedReceived, expectedCycles, receivedCycles) {
      return _replaceMatchedToAsymmetricMatcher(
        (0, _deepCyclicCopyReplaceable.default)(replacedExpected),
        (0, _deepCyclicCopyReplaceable.default)(replacedReceived),
        expectedCycles,
        receivedCycles
      );
    }
    function _replaceMatchedToAsymmetricMatcher(replacedExpected, replacedReceived, expectedCycles, receivedCycles) {
      if (!_Replaceable.default.isReplaceable(replacedExpected, replacedReceived)) {
        return {
          replacedExpected,
          replacedReceived
        };
      }
      if (expectedCycles.includes(replacedExpected) || receivedCycles.includes(replacedReceived)) {
        return {
          replacedExpected,
          replacedReceived
        };
      }
      expectedCycles.push(replacedExpected);
      receivedCycles.push(replacedReceived);
      const expectedReplaceable = new _Replaceable.default(replacedExpected);
      const receivedReplaceable = new _Replaceable.default(replacedReceived);
      expectedReplaceable.forEach((expectedValue, key) => {
        const receivedValue = receivedReplaceable.get(key);
        if (isAsymmetricMatcher(expectedValue)) {
          if (expectedValue.asymmetricMatch(receivedValue)) {
            receivedReplaceable.set(key, expectedValue);
          }
        } else if (isAsymmetricMatcher(receivedValue)) {
          if (receivedValue.asymmetricMatch(expectedValue)) {
            expectedReplaceable.set(key, receivedValue);
          }
        } else if (_Replaceable.default.isReplaceable(expectedValue, receivedValue)) {
          const replaced = _replaceMatchedToAsymmetricMatcher(
            expectedValue,
            receivedValue,
            expectedCycles,
            receivedCycles
          );
          expectedReplaceable.set(key, replaced.replacedExpected);
          receivedReplaceable.set(key, replaced.replacedReceived);
        }
      });
      return {
        replacedExpected: expectedReplaceable.object,
        replacedReceived: receivedReplaceable.object
      };
    }
    function isAsymmetricMatcher(data) {
      const type = (0, _jestGetType.getType)(data);
      return type === "object" && typeof data.asymmetricMatch === "function";
    }
    var diff = (a, b, options) => shouldPrintDiff(a, b) ? (0, _jestDiff.diff)(a, b, options) : null;
    exports.diff = diff;
    var pluralize = (word, count) => `${NUMBERS[count] || count} ${word}${count === 1 ? "" : "s"}`;
    exports.pluralize = pluralize;
    var getLabelPrinter = (...strings) => {
      const maxLength = strings.reduce(
        (max, string) => string.length > max ? string.length : max,
        0
      );
      return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
    };
    exports.getLabelPrinter = getLabelPrinter;
    var matcherErrorMessage = (hint, generic, specific) => `${hint}

${_chalk.default.bold("Matcher error")}: ${generic}${typeof specific === "string" ? `

${specific}` : ""}`;
    exports.matcherErrorMessage = matcherErrorMessage;
    var matcherHint = (matcherName, received = "received", expected = "expected", options = {}) => {
      const {
        comment = "",
        expectedColor = EXPECTED_COLOR,
        isDirectExpectCall = false,
        // seems redundant with received === ''
        isNot = false,
        promise = "",
        receivedColor = RECEIVED_COLOR,
        secondArgument = "",
        secondArgumentColor = EXPECTED_COLOR
      } = options;
      let hint = "";
      let dimString = "expect";
      if (!isDirectExpectCall && received !== "") {
        hint += DIM_COLOR(`${dimString}(`) + receivedColor(received);
        dimString = ")";
      }
      if (promise !== "") {
        hint += DIM_COLOR(`${dimString}.`) + promise;
        dimString = "";
      }
      if (isNot) {
        hint += `${DIM_COLOR(`${dimString}.`)}not`;
        dimString = "";
      }
      if (matcherName.includes(".")) {
        dimString += matcherName;
      } else {
        hint += DIM_COLOR(`${dimString}.`) + matcherName;
        dimString = "";
      }
      if (expected === "") {
        dimString += "()";
      } else {
        hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected);
        if (secondArgument) {
          hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument);
        }
        dimString = ")";
      }
      if (comment !== "") {
        dimString += ` // ${comment}`;
      }
      if (dimString !== "") {
        hint += DIM_COLOR(dimString);
      }
      return hint;
    };
    exports.matcherHint = matcherHint;
  }
});

export {
  require_build,
  require_build2,
  require_build5 as require_build3
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-IPPSHGG6.js.map
